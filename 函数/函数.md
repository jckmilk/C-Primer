## 6.1 函数基础
``````
返回类型 函数名(参数)
{
    函数体
}
``````
* 调用函数
  * 实参初始化对应的形参
  * 将控制权转移给被调用函数
* 形参和实参
  * 实参是形参的初始值
  * 数量相等
  * 类型匹配(转换)
* 函数返回类型
  * void 不返回任何值
  * 返回值不能是数组,函数
  * 可以使指向数组或函数的指针
### 6.1.1局部对象
* 形参和函数体内部定义的变量统称为局部变量,仅在函数的作用域可见
* 局部变量隐藏外层作用域的其他所有声明
* 局部静态对象,程序终止才销毁

### 6.1.2 函数声明
* 函数的名字也必须使用之前声明
* 函数只能定义一次,可以声明多次
* 函数声明也叫函数原型
* 函数声明放在头文件中

### 6.1.3分离式编译

## 6.2 参数传递
* 形参由实参初始化得到
* 形参数引用类型,它将绑定到实参上
* 否则,实参拷贝赋值给形参

### 6.2.1 传值参数

* 非引用类型形参不会改变实参的值.
* 执行指针拷贝操作时,拷贝的是指针的值,是不同的指针,通过指针可以修改所指对象的值
* 对引用的操作实际上是作用在所引用的对象上.
* 使用引用避免拷贝
  * 拷贝大的类类型对象或容器比较低效,当某种类型不支持拷贝,函数只能使用引用形参访问该类型的对象
  * 函数无需改变引用形参的值,最好声明为常量引用
  * 使用引用形参返回额外信息
    * 一个函数只有一个返回值,如果需要同时返回多个值,引用形参提供了有效的途径(类似于于socket变成中的socket等函数的使用)
  
### 6.2.3 const形参和实参

* 用实参初始化形参时会忽略顶层const,***形参的const会被忽略***
* 当形参由const时,传递给它常量和非常量都是可以的
  ``````
  void fcn(const int i)
  void fcn(int i)//同一个函数
  ````````
* 可以使用非常量初始化一个底层const对象,反过来不行
* 一个普通的引用必须用同类型的对象初始化
* 不能用字面值初始化一个非常量引用,常量引用是可以的.
* 尽量使用常量引用
  * 常量引用可以传递更多的类型
  * 显式说明无法被修改(具体看p192的解释)

### 6.2.4数组形参
* 数组不可以被拷贝
* 函数传递数组,实际传输的是指向数组首元素的指针
  * 使用标记指定数组长度,典型为c分割字符串
  * 使用标准可规范,数组的首指针和尾后指针,begin()和end()函数
  * 显式传递一个表示数组大小的形参
* 数组引用形参,int (&arr)[10]
* 传递多维数组,首元素本身是一个数组,指针就是一个指向数组的指针 int (*arr)[10]

### 6.2.6 含有可变形参的函数

* initializer_list,实参类型相同
  * 与vector不同的是,无法改变initializer_list中的对象的值p198
* 省略符形参,c语言
  * 只能出现在形参列表的最后一个位置
  
## 6.3 返回类型和return语句

* return 语句终止当前正在执行函数,并将控制权返回调用该函数的地方.

### 6.3.1 无返回值的函数

* 无返回值的return只能用在void函数中
* 中间位置提前退出,可以使用return语句

### 6.3.2 有返回值函数

* return的返回值必须和函数的返回类型相同或者能隐式转换的返回类型
* 在含有return语句的循环中应该也有一条return语句
  ```````
  bool str_subrange(const string& str1, const string& str2)
  {
      if(str1.size()==str2.size())
      return str1==str2;
      auto size=str1.size()<str2.size()?str1.size():str2.size();

      for(decltype(size) i=0;i!=size;i++)
      {
          if(str1[i]!=str2[i])
          return;//错误 无返回值
      }
      //错误控制流无任何返回值就结束了函数的执行
  }
  ````````
* 值是如何被返回的
  * 返回一个值的方式和初始化变量和形参的方式完全一样,返回的值用于初始化调用点的一个临时变量

* 不要返回局部对象的引用和指针
* 调用运算符的优先级和点运算符和箭头运算符相同,符合左结合律
* 调用一个函数,返回值引用是左值,其他类型是右值
* 可以为返回类型是非常量引用赋值
* 列表初始化返回值 花括号
  
### 6.3.3 返回数组指针

* 数组不能被拷贝,不能返回数组
* 可以返回数组的指针或引用
* 使用类型别名简化数组的指针或引用
* 声明一个返回数组指针的函数,数组的维度必须跟在函数名字之后
  `````
  type (*function(parameter_list))[dimesion]
  int (*func(int i))[10];
  ````````
* 尾置类型
  ````
  auto func(int i)->int(*)[10];
  `````
* 如果知道函数返回的指针指向哪个数组,就可以使用decltype 关键字声明返回类型,注意 decltype不会将数组转换为指针.
  
## 6.4 函数重载

* 同一作用域内几个函数名字相同但形参列表不同,为重载
* main函数不能重载
* 重载函数应该在形参数量和类型上有所不同
* 形参列表一样,返回类型不同,不是重载函数
* 重载和const形参
  * 顶层const不影响传入函数的对象
  * 形参是指针或引用,通过区分其指向是常量对象还是非常量实现重载.此时 const是底层的.
  * const实参只能使用const重载版本
  * 非常量对象和指向非常量对象的指针,可以使用两个版本,编译器优先选择非常量v版本.
  * const_cast p209

### 6.4.1 重载和作用域
* 将函数声明置于局部作用域内不是一明智的选择
* 内层作用域中声明的名字将隐藏外层作用域声明的同名实体
* 不同作用域无法重载函数名

## 6.5 特殊用途语言特性

### 6.5.1默认实参
* 经常使用默认值的形参出现在后面
* 某个形参被赋予默认值,后面的所有形参都必须默认值
* 局部变量不能作为默认实参

### 6.5.2 内联函数和constexpr函数
p213-215
### 6.5.3 调试帮助
* assert预处理宏
* NDEbug预处理变量


## 6.6函数匹配
* 形参类型可以相互转换时,要进行函数匹配
  * 确认候选函数和可行函数
    * 候选函数与调用函数同名,声明在调用点可见
    * 考察实参,从候选函数中选取可用函数,需要满足形参和实参数量相同,类型相同或可以相互转换.
  * 寻找最佳匹配
    * 从可行函数中选择与本次调用最匹配的函数:类型越接近,匹配的越好.
    * 依次检查每个参数以确定最佳匹配,如果匹配的最佳函数多于2个,则编译器提示错误.

## 6.7 函数指针

``````
bool (*pf)(const string &, const string &)
```````
* 不能忘记(*pf)
* 把函数名作为值使用时,该函数自动转化为指针
  `````
  pf=lengthcompare;
  pf=&lengthcompare;
  //等价
  ```````
  ````````
  bool b1=pf("hello","goodbyr");
  bool b2=(*pf)("hello","goodbyr")
  bool b3=lengthcompare("hello","goodbyr")
  //等价
  ````````
* 函数指针形参
  * 形参可以是函数声明,自动转化为指向函数的指针
  * 显式将形参定义为指向函数的指针
  * decltype得到的是函数类型
   ````````
   typedef bool func(const string &,const string&);
   typedef decltype(lengthcompare) func2;
   //等价 函数类型
   typedef bool (*funcp)(const string &,const string&);
    typedef decltype(lengthcompare) *func2;
    //等价 指针类型
   `````````
* 返回指向函数的指针

`````
using PF=int(*)(int*, int);//PF是指针类型
`````
`````
auto f1(int)->int(*)(int*,int);
``````


  

