## 4.1 基础
* 对于多个运算符的复杂表达式,要注意优先级和交换律
* 在表达式求值的过程中,通常会发生类型转换
* 可以为类类型生成自定义的重载运算符,但是运算对象的个数和优先级无法改变.
* 左值和右值
  一个左值表达式的求值结果是一个对象或函数
  * 当一个对象被用做右值时,用的是对象的值(内容),用到左值的时候用到的对象的身份(在内存中的位置)
  * 右值可以被左值代替,但左值不能被右值代替
  * 赋值运算符需要一个左值作为其左侧对象,得到的结果也是一个左值
  * 取地址符作用于一个左值,得到一个右值指针
  * 内置解引用,下表,迭代器解引用,string和vector的下标的求值结果都是左值
  * 关键字decltype,表达式结果是左值,得到引用类型
* 优先级和结合律
  * 括号无视优先级和结合律
* 求值顺序
  * 一般情况下,不会指定求值顺序
  * 没有指定顺序的运算符,如果表达式值指向并修改了同一个对象,将引发未定义的错误
  * 有四种运算符规定了求值顺序
    * && 先求左侧对象,左侧为真才求右侧
    * || 先求左侧,左侧为假才求右侧
    * a?b:c,a为真,求b,否则求c
    * , 从左向右求值
  * 求值顺序和优先级和交换律无关
    `````
    f()+g()*h()+j()
    `````
    这些函数的调用顺序没有明确规定,如果都是无关函数,则函数调用顺序不受限制,如果某几个函数影响同一个函数,则会产生未定义的行为.

## 4.2算术运算符
|算术运算符|功能|用法|
|:-:|:-:|:-:|
|+|一元正号|+exr|
|-|一元负号|-exr|
|*|乘法|exr  * exr|
|/|除法|exr/exr|
|%|求余|exr%exr|
|+|加法|exr+exr|
|-|减法|exr-exr|
* 可以作用余任何算数类型
* 一元运算符的优先级最高
* 优先级啊相同时,按照从左往右的顺序进行组合
* 算术运算符的运算对象和求值结果都是右值.
* 大多数运算中,布尔值被转换为int类型
* 取余运算的两个值必须输整数
* (-m)/n=-(m/n),m/(-n)=-(m/n)
* 如果m%n不等于0,则它的负号和m相同,即m%(-n)=m%n,(-m)%n=-(m%n);

## 4.3逻辑和关系运算符
* 关系运算符作用于算术类型或指针类型
* 逻辑运算符作用于任何能转换成布尔值的类型
* 运算对象和结果都是右值
* 进行比较运算符除非比较对象是布尔类型,否则不要用true和false作为比较对象
  
|结合律|运算符|功能|用法|
|:-:|:-:|:-:|:-:|
|右|!|逻辑非|!exr|
|左|<|小于|expr<exr|
|左|<=|小于等于|exr <=exr|
|左|>|大于|exr>exr|
|左|>=|大于等于|exr>=exr|
|左|==|相等|exr==exr|
|左|!=|不等|exr!=exr|
|左|&&|逻辑与|expr&&expr
|左|\\|逻辑或|expr \\expr|

## 4.4赋值运算符
* 赋值运算符的左侧必须是一个可修改的左值,返回一个左值
* 满足右结合律,多重赋值需要对象类型可以互相转换
* 赋值优先级比较低,在条件语句只能怪通常加上括号

## 4.5递增和递减运算符
* 除非必须,否则不使用递减递增运算符的后置版本
  ````
  *iter++ = *(iter++)//解引用的对象仍然是未加1的变量
  `````
* 递增递减运算符会改变对象的值,因此需要注意求值顺序,防止发生未定义的行为

## 4.6成员访问运算符
* 点运算符和箭头运算符都可以用于访问成员 ptr->mem=(*ptr)->mem;
* 解引用运算符低于点运算符,解引用要加括号
  
## 4.7条件运算符
````
cond?expr1:expr2;
``````
* 条件运算符值求expr1和expr2中的一个值
* 嵌套条件运算符,满足右结合律.
* 条件运算符的优先级啊非常低,一般需要加括号

## 4.8位运算符
## 4.9 sizeof运算符
* sizeof运算符返回一个表达式或类型名字所占的字节数.满足右结合律,所得的值为size_t类型的常量表达式.
* sizeof不实际计算其运算对象的值
  `````
  sizeof(type);
  sizeof expr;
  `````
* sizeof数组不会把数组变为指针
* 对string和vector执行只会计算固定部分大小,不会计算元素占用空间

## 4.10逗号运算符
* 从左到右求值
* 首先对左侧表达式求值,然后将值结果丢弃,真正的结果是右侧表达式的值
## 4.11类型转换
## 4.12 运算符优先级表




  