## 2.1 内置类型

### 2.1.1算术类型

|类型| 含义|最小尺寸|
|:-:|:-:|:-:|
|bool|布尔类型|未定义|
|char|字符|8位|
|wchar_t|宽字符|16位|
|char16_t|Unicode字符|16位|
|char32_t|UUnicode字|32位|
|short|短整型|16位|
|int|整型|16位|
|long|长整型|32位|
|long long|长整型|64位|
|float|单精度浮点|6位有效数字|
|double|双精度浮点|10位有效数字|
|long double|扩展精度|10位有效数字|

### 2.1.2 类型转换
* 非布尔赋值布尔,初始值为0结果为false,非0为true.
* 布尔赋值非布尔,初始值为false为0,true为1.
* 浮点赋值整型,仅保留浮点前面的整数部分.
* 整数赋值浮点,小数记为0.
* 无符号赋值超过范围,则取模结果为结果
* 有符号赋值超过范围,结果未定义.

#### 含有无符号类型的表达式
* 当表达式中同时存在int 和无符号, int 转换为无符号.
* 当从无符号数减去一个值,不管这个数是不是无符号数,结果不能是负值.
  

## 2.1.3 字面值常量

* 整型和浮点型字面值
  * 以0开头的八进制,以0x开头的十六进制
  * 默认十进制默认有符号
  * 浮点默认double.
* 字符和字符串字面值
  * 编译器在每个字符串结尾处添加在一个空字符('\0')
  * 字符串长度为字符个数加1
* 转义序列
  * 不可打印字符和特殊含义字符不能直接使用,需要使用转义序列,以反斜杠开始.
  * 泛化转义序列\x后跟1或多个十六进制,\后跟1,2,3个八进制数字
  * \后面超过3个八进制数字,只有前三个构成转义,\x需要后面所有十六进制数.

## 2.2 变量

* 变量定义
  * 变量定义形式: 类型说明符 变量名,定义时还可以进行赋值.
  * 对象是指一块能存储数据并具有某种类型的内存空间
  * 对象可以被修改,而值是只读数据
* 初始值
  * 对象创建时获得一个特定的值,称为初始化
  * 初始化不是赋值,初始化是创建变量时赋予的一个初始值,而赋值是将对象的当前值擦除,以新值代替.
* 列表初始化
  * 用花括号初始化变量叫列表初始化
  ````
  初始化四种方法:
  int a=0;
  int a={0};
  int a{0};
  int a(0);
  ``````
  * 使用初始化列表且初始值由丢失信息的风险,则编译器会报错.
* 默认初始化
  * 如果定义变量没有指定初始值,则变量默认初始化
  * 内置类型未显式初始化,它的值由定义的位置确定.
    * 任何函数体之外初始化为0.
    * 定义在函数体内部不被初始化.
    * 未初始化的内置类型是未定义的.
    * 类的初始化由类决定
* 变量声明和定义的关系
  * 声明使名字被程序所知
  * 一个文件想使用别处定义的名字则必须包含声明
  * 定义负责创建实体
  * 声明一个变量而不是定义,使用extern关键字,并且不显式初始化变量
  * 显式初始化的声明为定义
  * 定义只有一个,声明可以有多个.
* 标识符
  * 字母,数字,下划线,必须字母或下划线开头
  * 变量名一般用小写字母
  * 用户定义类名以大写字母开头
  * 多单词标识符中间应有明显区分.
* 嵌套作用域
  * 允许内层作用域重新定义外层作用域的名字
  * 一般,不要定义重复的全局变量和局部变量名.

## 2.3复合类型

* 引用
  * 引用是为对象另起一个名字
  * 引用不是赋值,而是绑定,引用必须初始化.
  * ***引用不是对象***,是为已经存在的对象的一个别名.
  * 引用只能绑定对象,不能绑定字面值和表达式结果.引用只能绑定最初的对象.
  * 类型要匹配
* 指针
  * 指针本身是对象,允许对指针拷贝和赋值
  * 指针无需在定义时赋初值,块作用域的指针如果不初始化将拥有不确定的值.
  * 类型要匹配
  * *p为解引用符号,并不是一个数值,而是说明可以访问变量p
    * int &e= *p;
  * 空指针
    * nullptr
    * 直接以0初始化
    * NULL,需要头文件cstdlib
  * 初始化所有指针
    * 赋值永远改变的是等号左边的对象
    * 指针为0,条件为false.
  * void*指针
* 理解符合类型的声明
  * 指向指针的引用
  ````
  int *p;
  int *&r=p;
  ````
  理解r的类型,最简单的办法是从右向左阅读,离r最近的符号对变量的类型有最直接的影响.

## 2.4 const限定符

* const和初始化
  * const类型的变量只能执行不改变其内容的操作,const变量必须初始化.
  * 初始化是不改变const对象的操作,一个对象初始化另一个对象,它们是不是const都无关紧要.
  ``````
  int i=42;
  const int ci=i;
  int j=ci;
  ``````
* 默认状态下,const对象被设置为尽在文件内有效,当对个文件中出现了同名的const变量,等同于在不同文件中的独立变量
* 多个文件共享const变量,则需要对变量不管是定义还是声明都加上extern关键字.

* const引用
  * 例外:初始化常量引用时允许用任意表达式作为初始值,只要该表达式能转换成引用的类型.
  `````
  以下表达均正确:
  int i=42;
  const int &r1=i;//正确
  const int &r2 = 42;//正确
  const int &r3=r1*2;//正确
  int &r4 = r1*2;//错误
  ````````
* 常量引用仅对引用可参与的操作进行了限定,对于引用对象本事是不是常量不做限定.,对象也可能是非常量,可以通过其他途径改变它的值.
  `````
  int i=42;
   int &r1=i;
  const int &r2 = i;
  r1=0;//正确
  r2=0;//错误
   ``````
* 指针和const
  * 指向常量的指针不能用于改变所指对向的值,常量指针必须初始化.
  * 指针类型和所指类型要一致,以下例外:
    * 允许一个指向常量的指针指向一个非常量对象.(同引用一致)
    * 指向常量的指针也没有规定所指的对象必须是一个常量.
* const指针
  ``` 
  int *const a=b;
  ````
ex 2.28 ***const对象必须初始化***

* 顶层const
  * 顶层const表示指针本身是常量
  * 底层const表示指针所指的对象是常量
  * 顶层const可以表示任意的对象是常量
  * 底层const则与指针和引用等复合类型的基础类型部分有关
  * 指针既可以是顶层const也可以是底层const.
  * 执行对象拷贝时,常量是顶层const还是底层const区别明显
    * 顶层const不受影响,执行拷贝并不会改变拷贝对象的值
    * 底层const不容忽视,执行拷贝时,对象必须具有相同的底层const资格,或者能够转换.
  * 具体看p58页的总结.
* constexpr和常量表达式
  * 常量表达式是指值不会改变在编译过程就能得到结果的表达式
  * 字面值是常量表达式,用常量表达式初始化的const对象也是常量表达式
  * 使用constexpr在编译阶段检查变量的值是否是常量表达式.
  * constexpr用到的类型一般为字面值类型,算数类型 指针和引用是,其他不是.
  * constexpr在有指针的限定符中,只对指针有效.
  
## 2.5处理类型
* 类型别名 使用typedef为类型起一个简单的名字.
* 别名声明 using .
````
typedef char *pstring;
const pstring cstr=0;
const pstring *ps
``````
不要简单的将类型进行替换, pstring 是 char*的别名 pstring是指向char的常量指针,而不是指向const char的指针.
* auto类型说明符
  * auto让编译器自动分析表达式的类型,auto定义的变量必须有初始值
* decltype 类型指示符
  * 希望从表达式中推断变量的类型,但是不想用该表达式的值初始化变量.

## 2.6自定义数据结构

### 2.6.1 定义Sales_data 类型
````
struct Sales_data{
    std:string bookNo;
    unsigned units_sold=0;
    double revenue=0.0;
};
Sales_data accum, trans, *salesptr;
`````
* 类的数据成员
* 可以为数据成员提供一个类内初始值





